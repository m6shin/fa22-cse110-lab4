1. Line 12 will print 3 since the console logs i after the for loop iterates i from 0 to 3. Hence, i is 3.
2. Line 13 will print 150 since the console logs the output from line 7 when var i = 2. The equation is var discountedPrice = prices[2] * (1 - 0.5) = 300 * 0.5 = 150.
3. Line 14 will print since the console logs the output from line 8 when var i = 2. The equation is Math.round(150 * 100)/100 = 150.
4. The function returns the array [50, 100, 150] since after each loop iteration we push a finalPrice value into the discounted array. The array we used was [100, 200, 300]. For the value 100, after computations we get 50 and push it into the discounted array. For the value 200, after computations we get 100 and push it into the discounted array. For the value 300, after computations we get 150 and push it into the discounted array. 
5. Line 12 causes an error since i is declared in the for loop block as a let variable and thus, line 12 cannot access the i variable since it is outside the for loop block.
6. Line 13 causes an error since discountedPrice is declared in the for loop block as a let variable and thus, line 13 cannot access the discountedPrice variable since it is outside the for loop block.
7. Line 14 causes an error since finalPrice is declared in the for loop block as a let variable and thus, line 14 cannot  access the finalPrice variable since it is outside the for loop block.
8. The function returns the array [50, 100, 150] because the variable discounted was declared as a let variable, so it is only accessible in the function block. Line 16 is in the function block, so it returns the discounted array.
9. Line 11 will return an error because variable i was declared in the for loop block and thus, line 11 cannot access variable i since it is outside the for loop block.
10. Line 12 prints 3 since length was declared within the function block as a const variable and line 12 is in the function block. Thus, it can access length variable.
11. The function returns the array [50, 100, 150] since the variable discounted was declared as a const variable, so it is only accessible in the function block. Line 14 is in the function block, so it returns the discounted array.
12. A. student.name, B. student['Grad Year'], C. student.greeting(), D. student['Favorite Teacher'].name, E. student.courseLoad[0]
13. A. '32' since the added number is converted to a string and then concatenated. B. 1 since the string is converted to a number when subtracting a number from a string. C. 3 since null is converted to the number 0 and then added to 3 when we add null to a number. D. '3null' since the number is converted to a string then concatenated. E. 4 since true is converted to the number 1 and then added to get 4, F. 0 since null and false become the number 0 and then added together. G. '3undefined' since undefined is converted to a string then concatenated with the string '3'. H. NaN since undefined converts to Nan so you get 3 - Nan = Nan.
14. A. True since '2' is converted to the number 2 and 2 > 1. B. False since strings are compared by character-by-character, we are really comparing '2' < '1', which is false. C. True since the string '2' is converted to 2 and 2 == 2 holds true. D. False since === checks the equality while taking into account of datatypes, so 2 is a number and '2' is a string. E. False since true is numerically 1 and 1 is less than 2. F. True since Boolean(2) = true since the boolean of any value that's not the number 0, null, false, NaN, undefined, or empty is true.
15. We see that == compares two variables regardless of the variable's data type, whereas === is used to compare two variables, but  will check the datatype and compare two values.
16. We will get the array [2, 4, 6]. With the line modifyArray([1, 2, 3], doSomething), the for loop in the function modifyArray() runs 3 times since the length of the parameter array is 3. With each iteration, the doSomething function takes an element in the i-th position of the parameter array and pushes the output to the newArr array. The doSomething function multiplies the element by 2, so we get 1 * 2 = 2, 2 * 2 = 4, 3 * 2 = 6. Thus, newArr is [2,4,6] and modifyArray returns newArr.
17. The output is 1 4 3 2, all of which are on separate lines.